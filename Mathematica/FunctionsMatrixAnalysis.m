(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* Theses are functions that are needed when doing matrix algebra, especially when dealing with orthogonal designs *)

(* the commutator and anti-commutator *)
commute = (#1.#2 - #2.#1)&;
anticommute = (#1.#2 + #2.#1)&;

(*note that RH should be defined for my time and space as *)
RHanticommute = (HermConj[#1].#2 + HermConj[#2].#1)&;



orthocheck = If[Complement[(#1.Transpose[#2] + #2.Transpose[#1])//Flatten,{0}]=={},0,1]&;
clifford = (#1.#2 + #2.#1)&;
cliffordcheck = If[Complement[(#1.#2 + #2.#1)//Flatten,{0}]=={},0,1]&;
cliffordQ = If[Complement[(#1.#2 + #2.#1)//Flatten,{0}]=={},True,False]&;

(* matrix trace. Not needed in math 4 and on *)
(* Tr = (intermat = # //. hermrule;
		    If[MatrixQ[intermat], 
     			intertrace = Sum[intermat[[jx,jx]],{jx,1,Length[intermat]}], 
			     (*Print["Not a matrix!"];*) intertrace = intermat];
   	 	intertrace)&;
*)



(* ::Input::Initialization:: *)
UnitMatrix = (
DiagonalMatrix[Table[1,{#}]]
)&;

unit2 = UnitMatrix[2];
unit3 = UnitMatrix[3];
unit4 = UnitMatrix[4];
unit5 = UnitMatrix[5]; unit5 //mf
unit6 = UnitMatrix[6];
unit7 = UnitMatrix[7];
unit8 = UnitMatrix[8];
unit16 = UnitMatrix[16];
unit32 = UnitMatrix[32]; 


(* ::Input::Initialization:: *)
AntiDiagonalMatrix  =Module[
{dim,mat,jk},
dim = #1;
mat = Table[0,{dim},{dim}]; 
(mat[[#,dim+1-#]]=1) &/@ Table[jk,{jk,1,dim}];
mat
]&;

(* Example use *)
AntiDiagonalMatrix [3] //MatrixForm


(* ::Input::Initialization:: *)
ZeroMatrix = Table[0,{#},{#}]&;

(* Example use *)
ZeroMatrix[3]


(* ::Input::Initialization:: *)
sigx={{0,1},{1,0}};
sigy={{0,-I},{I,0}};
sigz={{1,0},{0,-1}};

commute[sigx,sigy]/2 - I*sigz
commute[sigy,sigz]/2 - I*sigx
commute[sigz,sigx]/2 - I*sigy


(* ::Input::Initialization:: *)
(* the corresponding hermitean normalized spin-matrices are sigj/2 *)

(* an unorthodox collection of sigmas! *)

sig0 = unit2;
sig1 = I sigy;
sig2 = I sigx;
sig3 = sigz;

(* real matrices used in orthogonal designs *)

tau0 = unit2;
tau1 = sigx;
tau2 = I sigy;
tau3 = sigz;
splus  = {{0,1},{0,0}};   (* = sx + I sy = (sigx + I sigy)/2 *)
sminus = {{0,0},{1,0}};  (* = sx - I sy = (sigx - I sigy)/2 *)

(* These have correct commutation rules*)
commute[splus,sminus]-sigz
commute[sigz/2,splus] - splus
commute[sigz/2,sminus] + sminus
(**)


(* ::Input::Initialization:: *)
Collapse = (Complement[#//Flatten,{0}])&;
(* Example use *)
sigx //MatrixForm
Collapse[sigx]


(* ::Input::Initialization:: *)
Tensor = (
   outint = #1; intint = #2;
 In1Vec=False;In2Vec =False;
 If[!MatrixQ[outint],In1Vec=True;outint = {outint}];
   If[!MatrixQ[intint],In2Vec=True;intint = {intint}];
   em1 = Length[outint]; en1 = Length[outint[[1]]];
   em2 = Length[intint]; en2 = Length[intint[[1]]];
   internal = Table[0,{em1*em2},{en1*en2}]; 
	Do[internal[[i + (j-1)em2,k + (l-1)en2]] = outint[[j,l]]*intint[[i,k]],{k,1,en2},{i,1,em2},{l,1,en1},{j,1,em1}];
		If[In1Vec &&In2Vec,internal[[1]],internal])&;


(* ::Input::Initialization:: *)
Tensor3 = Module[{},Tensor[#1,Tensor[#2,#3]]]&;


(* ::Input::Initialization:: *)
Tensor[unit2,unit2]+Tensor[sigx,sigx]+Tensor[sigy,sigy]+Tensor[sigz,sigz] //MatrixForm
Tensor[unit2,unit2]+Tensor[sigz,unit2]+Tensor[unit2,sigx]-Tensor[sigz,sigx] //MatrixForm


(* ::Input::Initialization:: *)
TensorMany = Module[{args,num,res},
args = #1; 
num=Length[args];
res = args[[1]];
Do[res=Tensor[res,args[[nn+1]]],{nn,1,num-1}];
res
]&;

TensorMany[{sigx,sigz,sigy}] //mf


(* ::Input::Initialization:: *)
Commutator = Module[{First,Second},First = #1; Second = #2;First.Second - Second.First]&;


(* ::Input::Initialization:: *)
CommuteCheck = Module[{Fir,Sec},Fir = #1; Sec=#2; If[Union[Flatten[Normal[Commutator[Fir,Sec]]]]=={0},1,0]]&;

CommuteCheckSet = Module[{set,fir},set = #1; (fir = #; CommuteCheck[fir,#]&/@ set)&/@ set]&;

CommuteCheckSetInter2 = Module[{set1,set2,fir},set1 = #1; set2=#2;(fir = #; CommuteCheck[fir,#]&/@ set2)&/@ set1]&;

CommuteCheck[sig1,sig2]
CommuteCheck[unit2,sig2]

CommuteCheckSet[{unit2,sigx,sigz,sigy}] //mf

CommuteCheckSetInter2[{unit2,sigx},{sigz,sigy}] //mf


(* ::Input::Initialization:: *)
(* U/L = upper/lower, L/R = left/right*)


(* ::Input::Initialization:: *)
(* makes a matrix out of block-representation in terms of four matrices. The matrices need not be of same form, just that the dimensions are correct to construct a block matrix. If one of the arguments is a scalar, it is interpreted as a 1x1 matrix. If one of the argumetns is a vector,it is interpreted as a *column vector* *)

BlockMatrix = Module[{correctdimensions,firs,seco,thir,fourt,firsthori,firstvert,secondhori,secondvert},
correctdimensions = True;
(*first make possible scalars to vectors*)
If[!VectorQ[#1] &&  !MatrixQ[#1], firs = {#1}, firs = #1];
If[!VectorQ[#2]&&  !MatrixQ[#2], seco = {#2}, seco = #2];
If[!VectorQ[#3]&&  !MatrixQ[#3], thir = {#3} , thir = #3];
If[!VectorQ[#4]&&  !MatrixQ[#4], fourt = {#4}, fourt = #4];
(* Then make matrices of vectors. A vector is interpreted as a column vector*)
If[VectorQ[firs], firs = {#} &/@ firs];
If[VectorQ[seco], seco = {#} &/@ seco];
If[VectorQ[thir], thir = {#} &/@ thir];
If[VectorQ[fourt], fourt = {#} &/@ fourt];
(* Then check that the dimensions of the four blocks are correct*)
firsthori = Length[firs//Transpose];
firstvert = Length[firs];
secondhori = Length[fourt//Transpose];
secondvert = Length[fourt];
(*Print[firsthori,firstvert,secondhori,secondvert];*)
If[firstvert != Length[seco], correctdimensions = False];
If[Length[thir] != secondvert, correctdimensions = False];
If[firsthori != Length[thir//Transpose],  correctdimensions = False];
If[Length[seco//Transpose] != secondhori,  correctdimensions = False];
(* Finally build the matrix *)
If[correctdimensions,
     Join[Join[#[[1]],#[[2]]] &/@ ({firs,seco}//Transpose),
          Join[#[[1]],#[[2]]] &/@ ({thir,fourt}//Transpose)],
     Print["wrong dimensions!"]
     ]
]&;


(* ::Input::Initialization:: *)
(*Example use *)
BlockMatrix[sigx,sigy,sigy,unit2] //MatrixForm
BlockMatrix[sigx,{1,2},{{3,4}},5] //MatrixForm
BlockMatrix[5,{{3,4}},{1,2},sigx] //MatrixForm
BlockMatrix[{{3,4}},5,sigx,{1,2}] //MatrixForm
BlockMatrix[{1,2},sigx,5,{{3,4}}] //MatrixForm


(* ::Input::Initialization:: *)
(* makes a block diagonal  matrix out of block-representation in terms of four matrices. The matrices need not be of same form, just that the dimensions are correct to construct a block matrix. If one of the arguments is a scalar, it is interpreted as a 1x1 matrix. If one of the argumetns is a vector,it is interpreted as a *column vector* *)

BlockDiagonalMatrix = Module[{firs,seco,firsthori,firstvert,secondhori,secondvert,dummy,dummy2},
(*first make possible scalars to vectors*)
If[!VectorQ[#1] &&  !MatrixQ[#1], firs = {#1}, firs = #1];
If[!VectorQ[#2]&&  !MatrixQ[#2], seco = {#2}, seco = #2];
(* Then make matrices of vectors. A vector is interpreted as a column vector*)
If[VectorQ[firs], firs = {#} &/@ firs];
If[VectorQ[seco], seco = {#} &/@ seco];
(* if one or two of inputs are non-existent *)
If[Times@@Dimensions[firs]==0,
If[Times@@Dimensions[seco]==0,
(* the input was nothing, so output is nothing *)
{{}},
(* the first input was nothing *)
seco],
If[Times@@Dimensions[seco]==0,
(* the second was nothing, so output is first *)
firs,
(* both inputs non-trivial *)
(* Find dimensions of the blocks *)
firsthori = Length[firs//Transpose];
firstvert = Length[firs];
secondhori = Length[seco//Transpose];
secondvert = Length[seco];

(* Print[{firsthori,firstvert,secondhori,secondvert}]; *)
(* Finally build the matrix *)
dummy = Table[0,{firstvert},{secondhori}];
dummy2 = Table[0,{secondvert},{firsthori}];
     Join[Join[#[[1]],#[[2]]] &/@ Transpose[{firs,dummy}],
          Join[#[[1]],#[[2]]] &/@ Transpose[{dummy2,seco}]]
]]
]&;


(* ::Input::Initialization:: *)
OuterVectors = Module[{vec1,vec2},
vec1 = #1; 
vec2 = #2; 
({#} &/@ vec1).{vec2}
]&;


(* ::Input::Initialization:: *)
(* Analytic inversion of a matrix  using Adjoint. The Adjoint matric is the inverse matrix multiplied by the determinant of the matrix. *)


(* ::Input::Initialization:: *)
restrictmat = (mat = #1; droprow=#2; dropcol = #3;
            Drop[Drop[#,{dropcol}] &/@ mat, {droprow}]
            )&;

(* could also use Minors, but awkward *)

Adjoint = (If[MatrixQ[#] && (Length[#] == Length[Transpose[#]]),
              matint = #; lenint = Length[#]; 
              Table[(-1)^(ii+jj) Det[restrictmat[matint,jj,ii]], {ii,1,lenint},{jj,1,lenint}]
             ,(*else*) Print["Not a square matrix"]] )&;


(* ::Input::Initialization:: *)
(* Check correctness of Inverse in terms of Adj and det*)

(* *)
mat = {{a,b},{c,d}}; mat //mf
Adjoint[mat] //mf

mat = {{a,b,c},{d,e,f},{g,h,i}}; mat //mf
Adjoint[mat] //mf
Collapse[Inverse[mat] - Adjoint[mat]/Det[mat] //Together]



channel44  = {{Subscript[\[Alpha], 11],Subscript[\[Alpha], 21],Subscript[\[Alpha], 31],Subscript[\[Alpha], 41]},{Subscript[\[Alpha], 12],Subscript[\[Alpha], 22],Subscript[\[Alpha], 32],Subscript[\[Alpha], 42]},{Subscript[\[Alpha], 13],Subscript[\[Alpha], 23],Subscript[\[Alpha], 33],Subscript[\[Alpha], 43]},{Subscript[\[Alpha], 14],Subscript[\[Alpha], 24],Subscript[\[Alpha], 34],Subscript[\[Alpha], 44]}} //Transpose;
Adjoint[channel44] //mf

Collapse[Inverse[channel44] - Adjoint[channel44]/Det[channel44] //Together]



(* ::Input::Initialization:: *)
(* An analytic form of the Cholesky factorizatoin of a Hermitian matrix *)


(* ::Input::Initialization:: *)
(* {BA,A,B} = AnalyticCholesky[R];
   BA = B.A;
   R-HermConj[BA].BA =0
 *)


(* ::Input::Initialization:: *)
AnalyticCholesky = Module[{M,dim,rules,U,V},
M = #1;
dim = Length[M];
rules = Join[{1},(Sqrt[Minors[M,#][[1,1]]]) &/@ Table[jj,{jj,1,dim}]] //simp;
      U=Table[0,{dim},{dim}];
      Do[U[[kk,kk+ll-1]]=Minors[M,kk][[1,ll]],{kk,1,dim},{ll,1,dim-kk+1}];
      V = DiagonalMatrix[Table[1/(rules[[jj]]*rules[[jj+1]]),{jj,1,dim}]];
{V.U,U,V}]&;


(* ::Input::Initialization:: *)
(* A L x L DFT matrix *)


(* ::Input::Initialization:: *)
DFTmatrix = Module[{M,n,ROU},
n = #1;
M=Table[0,{n},{n}];
ROU=E^(-2I Pi/n);
      Do[M[[kk,ll]]=ROU^((kk-1)(ll-1)),{kk,1,n},{ll,1,n}];
  M/Sqrt[n]]&;

(* Example use *)

Nfft=8;
M=DFTmatrix[Nfft];Sqrt[Nfft]*M// MatrixForm
Conjugate[Transpose[M]].M  //simp//MatrixForm



(* ::Input::Initialization:: *)
(* A L x L DFT matrix, shifted so that center subcarrier is almost in middle:  Floor[Nfft/2]+1 is DC-subcarrier  *)


(* ::Input::Initialization::Closed:: *)
DFTmatrixShift = Module[{M,n,ROU},
n = #1;
M=Table[0,{n},{n}];
ROU=E^(-2I Pi/n);
      Do[M[[kk,ll]]=ROU^((kk-Floor[n/2]-1)(ll-Floor[n/2]-1)),{kk,1,n},{ll,1,n}];
  M/Sqrt[n]]&;



(* ::Input::Initialization:: *)
(* Example use *)
Nfft=9;
M=DFTmatrixShift[Nfft];Sqrt[Nfft]*M// MatrixForm
Sqrt[Nfft]*M[[Floor[Nfft/2]+1]]
Conjugate[Transpose[M]].M  //Simplify//MatrixForm

(* Direct connection between shifted and unshifted versions of DFT matrix *)
ShiftMat = DFTshiftMat[Nfft];
DFTmatrixShift[Nfft] - ShiftMat.DFTmatrix[Nfft].Transpose[ShiftMat]



(* ::Input::Initialization:: *)
(* The DFT-matrix as sampled phasors with integer frequency separation. Symmetric sampling and symmetric carriers *)
DFTmatrixSymm = Module[{M,n,ROU},
n = #1;
(* M=Table[0,{n},{n}];
ROU=E^(-2I Pi/n);
      Do[M[[kk,ll]]=ROU^(Expand[(kk-Floor[n/2]-1/2)(ll-Floor[n/2]-1/2)]),{kk,1,n},{ll,1,n}];
(* without changing the sampling points *)
Table[E^(-2 Pi I /Nfft*kk*tt),{kk,-(n-1)/2,(n-1)/2,1},{tt,-Floor[n/2],-Floor[n/2]+n-1}]/Sqrt[n];
*) 
Table[E^(-2 Pi I /Nfft*kk*tt),{kk,-(n-1)/2,(n-1)/2,1},{tt,-(n-1)/2,(n-1)/2,1}]/Sqrt[n]
]&;


(* ::Input::Initialization:: *)
CirculantMatrix = Module[{Vecarg},
Vecarg=#;
RotateRight[Vecarg,#] &/@ Table[j,{j,0,Length[Vecarg]-1}]//Transpose
]&


(* ::Input::Initialization:: *)
(* A L x L Walsh-Hadamard matrix, if L is power of 2*)


(* ::Input::Initialization:: *)
WHmatrix = Module[{L,WH2,OutPutMat},
L = #1;
WH2 = {{1,1},{1,-1}};  
OutPutMat={{1}};
If[N[Log[2,L]] - Round[Log[2,L]] ==0,
Do[OutPutMat = Tensor[WH2,OutPutMat],{j,1,Log[2,L]}];
OutPutMat, Print["Dimension not a power of 2"]]
]&;

(* Example use *)
M=WHmatrix[2];M// MatrixForm
M=WHmatrix[4];M// MatrixForm
M=WHmatrix[8];M// MatrixForm
Conjugate[Transpose[M]].M  //MatrixForm



(* ::Input::Initialization:: *)
(* A L x L Walsh-Hadamard matrix, if L is power of 2. The diagonal is identity, to keep the matrix as close to I as possible *)


(* ::Input::Initialization:: *)
WHmatrixDI = Module[{L,WH2,OutPutMat},
L = #1;
WH2 = {{1,1},{-1,1}};  
OutPutMat={{1}};
If[N[Log[2,L]] - Round[Log[2,L]] ==0,
Do[OutPutMat = Tensor[WH2,OutPutMat],{j,1,Log[2,L]}];
OutPutMat, Print["Dimension not a power of 2"]]
]&;

(* Example use *)
M=WHmatrixDI[2];M// MatrixForm
M=WHmatrixDI[4];M// MatrixForm
M=WHmatrixDI[8];M// MatrixForm
Conjugate[Transpose[M]].M  //MatrixForm



(* ::Input::Initialization:: *)
(* Acts as a permutation matrix of columns when acting from right. Argument is the final order of columns. Is transformed to a cycles as a list of perms. *)


(* ::Input::Initialization:: *)
PermutationMatrixRight = Module[{cycs,dim,PermMat,NonPermuted,Inxs,cyc},
cycs = PermutationCycles[Ordering[#1]];cycs = cycs[[1]];
dim=Max[#1];
PermMat = Table[0,{dim},{dim}];
NonPermuted = Complement[Table[jj,{jj,1,dim}],Flatten[cycs]];
Inxs = {#,#} &/@ NonPermuted;
Inxs = Join[Inxs,(cyc = #; Sequence@@(Transpose[{cyc,RotateLeft[cyc]}])) &/@ cycs];
(PermMat[[Sequence@@#]] = 1) &/@ Inxs;
PermMat
]&;


(* ::Input::Initialization:: *)

ord = {3,1,2,5,4,6};
ord = {2,3,1,4};
dim=Max[ord];
P = PermutationMatrixRight[ord];
TstMat = Table[jj,{dim},{jj,1,dim}];

{TstMat,TstMat.P, P,P.Transpose[P]} //mfl
lst = TstMat[[1]]
Permute[lst,PermutationCycles[Ordering[ord]]]


(* ::Input::Initialization:: *)
(* Diagonal coords first, then filling the off-diagonal rows from first to last *)


(* ::Input::Initialization:: *)
CreateSymmMatFromCoords = Module[{Coords,len,rr,DiagCoords,OffDiagCoords,UppInxs,Sr,InxAndCoordList},
Coords = #1;
(* The dimensions in terms of length of coordinate vector *)
len = Length[Coords];
If[len ==0,{{}},
rr = 1/2 (Sqrt[1+8*len]-1);
DiagCoords= Take[Coords,rr];
OffDiagCoords = Drop[Coords,rr];
(* Indexes to upper diagonal terms *)
UppInxs = Subsets[Range[rr],{2}];
Sr = Table[0,{rr},{rr}];
InxAndCoordList = Join[#[[1]],{#[[2]]}] &/@ Transpose[{UppInxs, OffDiagCoords}];
(Sr[[#[[1]],#[[2]]]] = #[[3]])  &/@ InxAndCoordList;
Sr + Transpose[Sr] + DiagonalMatrix[DiagCoords]
]
]&;

CreateSymmMatFromCoords[{1,2,3,4,5,6,7,8,9,10}] //mf
