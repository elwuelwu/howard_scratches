(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
GenerateGLn2 = Module[{mm,unitm,LowerDiags,inxs,mat,Geners},
mm=#1;
unitm =IdentityMatrix[mm];
(* One way of generating GL(n,2): an offdiagonal permutation, and lower diagonals *)
LowerDiags = (inxs = #;mat = unitm; mat[[Sequence@@inxs]]=1; mat) &/@ Table[{jj,jj-1},{jj,2,mm}]; 
Geners = Join[{RotateRight[unitm]},LowerDiags];
GenerateGroupMod2[Geners,30]
]&;


(* ::Input::Initialization:: *)
RandomGLn2 = Module[{mi,rank,matu},
mi = #1; 
rank  = 0; 

While[rank < mi,
matu = Table[RandomInteger[1],{mi},{mi}];
rank = MatrixRank[matu,Modulus->2]
]; 
matu
]&; 


(* ::Input::Initialization:: *)
 GenerateSn2 = Module[{m,posilist,Zerom,OffDiags,tup,matu,tups,AllBinSymm},
m=#1;
posilist = (row = #; Sequence@@({row,#}&/@ (Range[m-row]+row))) &/@ Range[m-1];
Zerom = Table[0,{m},{m}];
OffDiags = (tup = #; matu = Zerom; (matu[[Sequence@@(posilist[[#]])]] = tup[[#]]) &/@ Range[(m-1)m/2]; matu + Transpose[matu]) &/@ Tuples[{0,1},{(m-1)m/2}];
tups = Tuples[{0,1},{m}];
AllBinSymm = (matu = #; Sequence@@((matu + DiagonalMatrix[#]) &/@ tups)) &/@ OffDiags;
AllBinSymm]&;

MakeAllBinSymm  = GenerateSn2[#]&; 


(* ::Input::Initialization:: *)
RandomSn2 = Module[{mi,posilist,row, matu,diags,offdiags,posi,bit},
mi = #1; 
posilist = (row = #; Sequence@@({row,#}&/@ (Range[mi-row]+row))) &/@ Range[mi-1];
matu= Table[0,{mi},{mi}];
offdiags = RandomInteger[1,Length[posilist]];
diags = RandomInteger[1,mi];
(posi = #[[1]]; bit = #[[2]]; matu[[Sequence@@posi]] = bit) &/@ Transpose[{posilist,offdiags}];
matu = matu + Transpose[matu] + DiagonalMatrix[diags]
]&; 


(* ::Input::Initialization:: *)
(* This decomposes a binary symmetric matrix to a set of vectors, the outer products of which create the binary symmetric matrix  *)
(* NOTE: often there are more vectors than the rank of the matrix!! *)
(* sometimes the algorithm does not find a simple decomposition *)

DecomposeBinSymmToOuterProducts = Module[{symmi,mi, zeri,Zerom,PosiList,OffDiags,Diags,OffDVecs,vec,vece,DiagAdds,DVecs,AllVecs},
symmi = #1;
(* the m-values *)
mi = Length[symmi];
zeri = Table[0,{mi}];
Zerom = Table[0,{mi},{mi}];
PosiList =Position[symmi,1];
PosiList = Union [Sort[#] &/@ PosiList];
OffDiags = {};
If[#[[1]]!=#[[2]],AppendTo[OffDiags ,#]] &/@ PosiList;OffDiags;
Diags = Union[Flatten[Complement[PosiList,OffDiags]]];
(* create off-diagonal elements from vectors with two non-zeroes *)
OffDVecs = (vec = Zerom[[1]];vec[[#]] = 1;vec) &/@ OffDiags; 
(* A vector indicating how often a diagonal element appears *)
vece = Flatten[Join[OffDiags,Diags]];
(* this indicates which diagonal elements one should add a one to *)
DiagAdds = Flatten[Position[Mod[Count[vece,#],2] &/@ Range[mi],1]]; 
(* create vectors *)
DVecs = (vec = Zerom[[1]];vec[[#]] = 1;vec) &/@ DiagAdds;
AllVecs = Join[OffDVecs,DVecs]; If[AllVecs=={},AllVecs={Table[0,{mi}]}]; AllVecs
]&;



(* ::Input::Initialization:: *)
SetsOfBinaryMatrices = Module[{m,AllBinMats,AllBinFullRank,AllBinFRCosets,AllBinSymm, kept, rema,new,Allmplets,ranks,DiffRanks,RankPartition,tups,AllAmats},
m=#1;
AllBinMats = Partition[#,m] &/@ Tuples[{0,1},{m^2}];
AllBinFullRank = Complement[If[MatrixRank[#,Modulus->2]==m,#] &/@ AllBinMats,{Null}];
(* All full rank matrices up to column permutation *)
kept = {}; rema = Transpose[(mat = #;  #/Norm[#] &/@ mat)] &/@ AllBinFullRank; (* normalize the vectors for easy identification of same vecs *)
While[Length[rema]>0,
new = rema[[1]]; AppendTo[kept,new];rema = Complement[If[Length[Position[Flatten[Transpose[new].#],1]]<m,#] &/@ rema ,{Null}]
];
AllBinFRCosets = Sign[Transpose[#]] &/@ kept;
(* All symmetric matrices *)
AllBinSymm = MakeAllBinSymm[m];
(* All distinct A-matrices: m-plets of distinct collections of m-bit a-vectors up to *row* perm *)
(* Ordered so that first 2^m are rank 0, the last Binomial[2^m-1,m] are such that all come from different non-diagonal a-subspaces, the next to last Binomial[2^m-1,m-1] are such that all come from differnet a-subspaces, and one is diagonal (a=0), and so on   *)
Allmplets = Union[Sort[#] &/@ Tuples[Range[2^m],{m}]];
ranks = Length[Union[#]] &/@ Allmplets;
DiffRanks = Union[ranks];
RankPartition = Flatten[Position[ranks,#]] &/@ DiffRanks;
Allmplets = Allmplets[[(Sequence@@#) &/@ RankPartition]];
tups =  Tuples[{0,1},{m}];
AllAmats = tups[[#]] &/@ Allmplets;
{AllBinMats,AllBinFullRank,AllBinFRCosets,AllBinSymm,AllAmats}
]&; 


(* ::Input::Initialization:: *)
SymplecticF1FromInvertible = Module[{Pp},
Pp = #1;
BlockMatrix[Pp, 0*Pp,0*Pp,Transpose[Inverse[Pp,Modulus->2]]]]&;

SymplecticF2FromSymm = Module[{Ss,uni},
Ss= #1;
uni= IdentityMatrix[Length[Ss]];
BlockMatrix[uni, Ss,0*Ss,uni] ]&;


(* ::Input::Initialization:: *)
DecomposeSymplectic = Module[{Spmat,mm,Aa,Bb,Cc,Dd,rr,Hh,CellInx,Pp,Pinv,Mup,Mlo,A2,B2,D2,Mm,Minv,Imr,Imnr,Sr,MSup,MSlo,MS,Ss},
Spmat = #1;
mm= Length[Spmat]/2;
Aa = Transpose[Take[Transpose[Take[Spmat,mm]],mm]]; 
Bb = Transpose[Take[Transpose[Take[Spmat,mm]],-mm]]; 
Cc = Transpose[Take[Transpose[Take[Spmat,-mm]],mm]]; 
Dd = Transpose[Take[Transpose[Take[Spmat,-mm]],-mm]];   {Aa,Bb,Cc,Dd} //mfl;

rr = MatrixRank[Cc,Modulus->2];
(* The reduced row echelon form of C gives the Schubert cell *)
If[rr>0,
Hh  = Transpose[Take[RowReduce[Transpose[Cc],Modulus->2],rr]]; Hh //mf;
CellInx = Min[Flatten[Position[#,1]]] &/@ Transpose[Hh];
(* Choose P to be the Schubert cell complemented with identity in remaining dimensions  *)
Pp = Join[Transpose[Hh],IdentityMatrix[mm][[Complement[Range[mm],CellInx]]]] //Transpose,
(* if rank = 0, take just P identiy *)
Pp = IdentityMatrix[mm]];   Pp //mf;
Pinv = Inverse[Pp,Modulus->2];

(* Compute M from upper part of C and lower part of A *)
Mup = Take[Mod[Pinv.Cc,2],rr];  A2 = Mod[Transpose[Pp].Aa,2]; Mlo = Take[A2,rr-mm];  Mm = Join[Mup,Mlo];   Mm //mf;
Minv = Inverse[Mm,Modulus->2];
Imr = DiagonalMatrix[Join[Table[1,{rr}], Table[0,{mm-rr}]]];
Imnr = IdentityMatrix[mm]-Imr;  
(* Compute Sr from A *)
Sr = Mod[A2.Minv +Imnr,2]; Sr//mf; 

(* Direct construction of UD subgroup element *)
(* Mod[Inverse[Mod[BlockMatrix[Transpose[Pinv],Zerom,Zerom,Pp].BlockMatrix[IdentityMatrix[mm],Sr,Zerom,IdentityMatrix[mm]].BlockMatrix[Imnr,Imr,Imr,Imnr],2],Modulus\[Rule]2].Spmat,2] //mf;
(* Direct construction of U subgroup element *)
Mod[Inverse[Mod[BlockMatrix[Transpose[Pinv],Zerom,Zerom,Pp].BlockMatrix[IdentityMatrix[mm],Sr,Zerom,IdentityMatrix[mm]].BlockMatrix[Imnr,Imr,Imr,Imnr].BlockMatrix[Mm,Zerom,Zerom,Transpose[Minv]],2],Modulus\[Rule]2].Spmat,2] //mf; *)

(* Compute S *)
D2 = Mod[Pinv.Dd - Imnr.Transpose[Minv],2]; MSup = Take[D2,rr];
B2 = Mod[Transpose[Pp].Bb - Imr.Transpose[Minv],2]; MSlo = Take[B2,rr-mm];
MS = Join[MSup,MSlo]; MS //mf;
Ss = Mod[Minv.MS,2]; Ss //mf;


(*
(* The analytic form of the Sp-matrix was found *)
Equas = {Aa,Bb,Cc,Dd}-Mod[{Pp.(Sr + Imnr).Mm, Pp.((Sr+Imnr).Mm.Ss+Imr.Transpose[Minv]),  Transpose[Pinv].Imr.Mm, Transpose[Pinv].(Imr.Mm.Ss + Imnr.Transpose[Minv])} ,2]//Flatten//Union;
*)

(* The decomposition in terms of intvertible, symmetric, Ful, invertible and symmetric matrices *)
(* Note that here the first Invertible is given in the conventional form, so that the lower block is given by ^-T of this*)
{Transpose[Pinv],Sr, BlockMatrix[Imnr,Imr,Imr,Imnr],Mm,Ss}
]&; 


(* ::Input::Initialization:: *)
DecomposeSymplecticMats = Module[{Spi,Pp,Sr,Io,Mm,Ss},
Spi = #1;
{Pp,Sr,Io,Mm,Ss} = DecomposeSymplectic[Spi];
(*{UnitaryF1rep[Pp],UnitaryF2rep[Sr],UnitaryFulrep[Io], UnitaryF1rep[Mm],UnitaryF2rep[Ss]}*)
{SymplecticF1FromInvertible[Pp],SymplecticF2FromSymm[Sr],Io,SymplecticF1FromInvertible[Mm],SymplecticF2FromSymm[Ss]}
]&; 


(* ::Input::Initialization:: *)
(* Creates the quotient of Sp(2m,2) w.r.t. the right subgroup. First with fixed rank, then for all ranks. *)
CreateQuotientFixedRank = Module[{mm,r,Imr,Subspaces,DiagSympls,Symms,UpperSympls,LeftMats,FOmega,Zerom,unitm},
mm=#1; r = #2; 
Zerom = Table[0,{mm},{mm}];
unitm = IdentityMatrix[mm];
(* Reduced rank identity at this rank *)
Imr = DiagonalMatrix[Join[Table[1,{r}],Table[0,{mm-r}]]];
(* find the GL(m) matrices that span the subspaces in this rank and the corresponding Sp matrices *)
Subspaces = ComplementedBinarySubspaces[mm,r];
(* Note that the Schubert cells are now arrange such that the lower right part of sympl *)
(* matrix has the first r columns in the cell *)
(* Thus one has to have the complemented Schubert in lower right *)
DiagSympls = BlockMatrix[Transpose[Inverse[#,Modulus->2]],Zerom,Zerom,#] &/@ Subspaces; 
(*  The symmetric matrices in this rank, and the corresponding Sp matrices *)
Symms = Union[Imr.#.Imr &/@ AllBinSymm];
UpperSympls = BlockMatrix[unitm,#,Zerom,unitm] &/@ Symms;
(* The semidirect product of all matrices *)
LeftMats = ProductsOfLists[DiagSympls,UpperSympls];
(* The center matrix at this rank *)
FOmega = BlockMatrix[unitm-Imr,Imr,Imr,unitm-Imr];
#.FOmega &/@ LeftMats
]&;

CreateQuotient = Module[{mm,r},
mm=#1; (r=#;Sequence@@(CreateQuotientFixedRank[mm,r]) ) &/@ Range[0,mm] ]&;


(* ::Input::Initialization:: *)
(* Creates the quotient of Sp(2m,2) w.r.t. the right subgroup. First with fixed rank, then for all ranks. *)
(* Here one takes a representative of the coset where right multiplication is performed in inverse order *)
CreateQuotientFixedRankSymm = Module[{mm,r,Imr,Subspaces,DiagSympls,Symms,UpperSympls,FOmega,pairs,pair,Ups,Dis,Zerom,unitm},
mm=#1; r = #2; 
Zerom = Table[0,{mm},{mm}];
unitm = IdentityMatrix[mm];
(* Reduced rank identity at this rank *)
Imr = DiagonalMatrix[Join[Table[1,{r}],Table[0,{mm-r}]]];
(* find the GL(m) matrices that span the subspaces in this rank and the corresponding Sp matrices *)
Subspaces = ComplementedBinarySubspaces[mm,r];
(* Note that the Schubert cells are now arrange such that the lower right part of sympl *)
(* matrix has the first r columns in the cell *)
(* Thus one has to have the complemented Schubert in lower right *)
DiagSympls = BlockMatrix[Transpose[Inverse[#,Modulus->2]],Zerom,Zerom,#] &/@ Subspaces; 
(*  The symmetric matrices in this rank, and the corresponding Sp matrices *)
Symms = Union[Imr.#.Imr &/@ AllBinSymm];
UpperSympls = BlockMatrix[unitm,#,Zerom,unitm] &/@ Symms;
(* The center matrix at this rank *)
FOmega = BlockMatrix[unitm-Imr,Imr,Imr,unitm-Imr];
(* all indexes of one upper, one diag sympl *)
pairs = Partition[Flatten[Outer[List,Range[Length[UpperSympls]],Range[Length[DiagSympls]]]],2];
(* construct orbit representatives by multiplying from right as well with the upper and diag sympls *)
(pair = #;
Ups = UpperSympls[[pair[[1]]]];
Dis = DiagSympls[[pair[[2]]]];
Mod[Dis.Ups.FOmega.Ups.Dis,2]
) &/@  pairs 
]&;

CreateQuotientSymm = Module[{mm,r,Imr,Subspaces,DiagSympls,Symms,UpperSympls,LeftMats,FOmega},
mm=#1; (r=#;Sequence@@(CreateQuotientFixedRankSymm[mm,r]) ) &/@ Range[0,mm] ]&;


(* ::Input::Initialization:: *)
CreateQuotientFromPS = Module[{mm,rr,Zerom, unitm,Pmat,Sr,Symm,Imr,DiagSympl,UpperSympl,LeftMat,FOmega},
Pmat = #1;
Sr = #2;
mm = Length[Pmat];
rr = Length[Sr];
Zerom = Table[0,{mm},{mm}];
unitm = IdentityMatrix[mm];
Symm = BlockMatrix[Sr,Table[0,{rr},{mm-rr}],Table[0,{mm-rr},{rr}],Table[0,{mm-rr},{mm-rr}]];
(* Reduced rank identity at this rank *)
Imr = DiagonalMatrix[Join[Table[1,{rr}],Table[0,{mm-rr}]]];
(* Note that the Schubert cells are now arranged such that the lower right part of sympl matrix has the first r columns in the cell *)
(* Thus one has to have the complemented Schubert in lower right *)
DiagSympl = BlockMatrix[Transpose[Inverse[Pmat,Modulus->2]],Zerom,Zerom,Pmat]; 
(*  The symmetric matrices in this rank, and the corresponding Sp matrices *)
UpperSympl = BlockMatrix[unitm,Symm,Zerom,unitm];
(* The semidirect product of all matrices *)
LeftMat = DiagSympl.UpperSympl;
(* The center matrix at this rank *)
FOmega = BlockMatrix[unitm-Imr,Imr,Imr,unitm-Imr];
LeftMat.FOmega
]&;


(* ::Input::Initialization:: *)
(* A function which creates the binary Schubert cells (columns), i.e. the Grassmannian elements of r-dimensional subspaces in GF2^m *)


(* ::Input::Initialization:: *)
CreateBinarySubspaces  =Module[{r,mm,CellInxs,startmat,cell,cellmat,inx,cinx,Varis,tuppers,tup,rule},
mm=#1;r=#2;
CellInxs = Subsets[Range[mm],{r}];
startmat = Table[Subscript[b, kk+mm*ll],{kk,1,mm},{ll,1,r}];
(* create the SchubertCells elements *)
(* The indexes show the position of the first, non-zero element. This is the only non-zero element in its row *)
(* the other elements are free *)
(cell = #;
cellmat = startmat;
(inx=#; cinx = cell[[inx]];cellmat[[cinx,inx]]=1;
(cellmat[[cinx,#]]=0) &/@ Complement[Range[r],{inx}];Do[cellmat[[kk,inx]]=0,{kk,1,cinx-1}];) &/@ Range[r];
Varis = Complement[Flatten[cellmat],{0,1}];
tuppers = Tuples[{0,1},{Length[Varis]}];
Sequence@@((tup = #; rule = (#[[1]]->#[[2]]) &/@ Transpose[{Varis,tup}]; cellmat /. rule) &/@ tuppers )
) &/@ CellInxs]&;


(* ::Input::Initialization:: *)
(* a function which creates all columnar m,r Schubert cell, complemented to invertible matrices *)
(* Complements directly by adding identity matrix in the complement *)
(* the Schubert cell *has to be in the r first columns*, with the remaing complementing. *)



(* ::Input::Initialization:: *)
(* old version was ad hoc *)
ComplementedBinarySubspacesOle = Module[{mm,r,SchubertCells,ComplementCells,Schu,inx,ran,Compl},
mm=#1; r=#2;
(* Created Schubert cell with wanted rank, and complementary rank *)
SchubertCells = Transpose[#] &/@ CreateBinarySubspaces[mm,r];
ComplementCells = Transpose[#] &/@ CreateBinarySubspaces[mm,mm-r];
(* find complement that makes the full matrix invertible *)
(Schu = #; Print[Schu];
inx=0; ran = 0;
While[ran<mm,
Increment[inx];
Compl = Join[Schu, ComplementCells[[inx]]];
ran = MatrixRank[Compl,Modulus->2];
];
Transpose[Compl]) &/@ SchubertCells]&;

ComplementedBinarySubspaces  =Module[{r,mm,bb,unit,CellInxs,startmat,cell,compcell,cellmat,inx,cinx,Varis,tuppers,tup,rule,perm,matsnow},
mm=#1;r=#2;
CellInxs = Subsets[Range[mm],{r}];
unit = IdentityMatrix[mm];
startmat = Table[Subscript[bb, kk+mm*ll],{kk,1,mm},{ll,1,r}];
(* create the SchubertCells *)
(* The indexes show the position of the first, non-zero element. This is the only non-zero element in its row *)
(* the other elements are free *)
(cell = #;
cellmat = startmat;
(inx=#; cinx = cell[[inx]];cellmat[[cinx,inx]]=1;
(cellmat[[cinx,#]]=0) &/@ Complement[Range[r],{inx}];Do[cellmat[[kk,inx]]=0,{kk,1,cinx-1}];
) &/@ Range[r];
(* the indices of the complemnt - rows not used *)
compcell = Complement[Range[mm],cell]; 
cellmat = Transpose[Join[Transpose[cellmat],unit[[compcell]]]];
(* the permutation that brings cellmat to lower triangular form. the inverse is perm.cellmat.perm *)
perm = unit[[Join[cell,compcell]]]; 
Varis = Complement[Flatten[cellmat],{0,1}];
tuppers = Tuples[{0,1},{Length[Varis]}];
matsnow = (tup = #; rule = (#[[1]]->#[[2]]) &/@ Transpose[{Varis,tup}]; cellmat /. rule) &/@ tuppers;
(* this shows that closed form inverses are OK *)
(*Print[Union[Flatten[(Mod[#.perm.#.perm,2]- unit) &/@ matsnow]]]; *)
Sequence@@( matsnow)
) &/@ CellInxs
]&;


(* ::Input::Initialization:: *)
(* Schubert Cell specirfic permutation matrices *)

CreateSchubertPerms  =Module[{r,mm,bb,unit,CellInxs,startmat,cell,compcell,cellmat,inx,cinx,Varis,tuppers,tup,rule,perm,matsnow},
mm=#1;r=#2;
CellInxs = Subsets[Range[mm],{r}]; 
unit = IdentityMatrix[mm];
(cell = #; compcell = Complement[Range[mm],cell]; 
(* the permutation that brings cellmat to lower triangular form. the inverse is perm.cellmat.perm *)
perm = unit[[Join[cell,compcell]]]
) &/@ CellInxs
]&;


(* ::Input::Initialization:: *)
(* finds the leading part of a Schubert cell element, which is a subset of the identity *)


(* ::Input::Initialization:: *)
SchubertImatFromElem = Module[{subspace,mi,ri,ZeroVec,inxs,out,perm},
subspace = #1; 
mi=Length[subspace]; ZeroVec = ConstantArray[0,mi];
subspace = Transpose[subspace];
inxs = Flatten[Position[#,1],1][[1]] &/@ subspace;
perm = (out = ZeroVec; out[[#]]=1; out) &/@ inxs;
Transpose[perm]
]&;


(* ::Input::Initialization:: *)
SchubertCellPermutation  = Module[{Pmat,rr,ZeroVec,Icelll,vve,PermCell},
Pmat = #1; rr = #2;
ZeroVec = Table[0,{mm}];
Icell = (vve = ZeroVec; first = Flatten[Position[#,1]][[1]]; vve[[first]]=1; vve) &/@ Take[Transpose[Pmat],rr];
PermCell = Join[Icell,Drop[Transpose[Pmat],rr]]
] & ;


(* ::Input::Initialization:: *)
(* finds a Cell in dual dimensions, such that it is orthogonal to the cell matrix Hmat *)


(* ::Input::Initialization:: *)
SchubertCellDual = Module[{Hmat,Imat,ComplInx,Inx,Imatcompl,Bcompl,Hcompl},
Hmat = #; 
Imat = SchubertImatFromElem[Hmat]; Bmat = Hmat -Imat; 
(* this vector has a one in the positions indicating the complementary dimensions *)
ComplInx = ConstantArray[1,mm]-Plus@@(Transpose[Imat]);
Inx = Flatten[Position[ComplInx,1]];
(* the complementary Schubert cell *)
Imatcompl= Transpose[IdentityMatrix[mm][[Inx]]];
Bcompl =  Imat.Transpose[Bmat].Imatcompl;
(* the complementary Schubert cell, orthogonal to subspace *)
Hcompl = Imatcompl + Bcompl
]&;


(* ::Input::Initialization:: *)
(* computes inverse of complemented subspace matrix by construction *)


(* ::Input::Initialization:: *)
InverseComplSchubertMat = Module[{Pmat,ri,Hmat,Imat,Hcompl},
Pmat = #1; ri = #2;
Hmat = Transpose[Take[Transpose[Pmat],ri]];
Imat = SchubertImatFromElem [Hmat];
Hcompl = SchubertCellDual[Hmat];
Join[Transpose[Imat],Transpose[Hcompl]]
]&;



